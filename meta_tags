#!/usr/bin/ruby

# ======================================================================
# 
# Configuring Textplay
# ====================
# 
# Using Fountain's `key:value` title-page syntax, you can control how
# textplay interperets your screenplay. The following values can
# be customized:
#
#     * title (for metadata only) -- default: "A Screenplay"
# 
#       You can define what name textplay uses when generating files.
#  
#     * goldman_sluglines -- default: ON
# 
#       By defualt textplay interprets any line that's all-caps as a
#       slugline.
# 
#     * screenbundle_comments -- default: ON
# 
#       To provide backwards-compatibility with screenbundle documents,
#       textplay interprets any line starting with 2 slahes `//` as comments.
# 
#     * font -- default: "Courier Prime"
# 
#       By default textplay uses "Courier Prime" <http://quoteunquoteapps.com/courierprime/>
#       a great alternative font for screenwriters. If you don't have that
#       installed plain Courier will be used.
#   
#       If you'd like to specify your own font, Courier Prime and Courier
#       will be used as backup fonts.
# 
#     * slugline_spacing -- default: 1
# 
#       By default textplay puts a single empty line above sluglines, you
#       can change this to any number you want.
# 
#     * bold_sluglines -- default: ON
#     * underlined_sluglines -- default: OFF
# 
#     * header -- empty by default
# 
#       Header information is displayed on every page, use this for
#       revision numbers, dates, etc.
# 
#     * footer -- empty by default
# 
#       Any information you'd like in the footer of every page can go here.
# 
# 
# For the time being, all other key/values are preserved as meta-data in
# the document, but otherwise ignored.
# 
# 
# 
# To set these values just define the key/values at the beginning of the
# document like this:
# 
# title: Ron's Woodland Adventure
# font: Courier New
# goldman_sluglines: off
# bold_sluglines: on
# 
# The block of key/value pairs:
#    a. Must be the first non-comment thing in the document.
#    b. Options CAN be wrapped in boneyard comments or notes
#    c. Options must NOT be indented
#    d. The block of option key/value pairs cannot contain more than
#       1 empty line. 2 empty lines will cause textplay to stop parsing
#       for options.
#
# For more details see the Fountain documentation 
# <http://fountain.io/syntax#section-titlepage>.
#
# ======================================================================

# read the input
# text = ARGF.read

# define test text
text = '
title: Erased
slugline_spacing: 2
'

# -------------------------

# define regex for key-value pairs

multi_key = /
  # Cannot begin with spaces (that's a value)
  ^(?!\ )
  # the key itself
  [\S\ ]+:\ *\n
  # the indented value - multiple lines allowed
  ((\ {3,}|\t).+\n?)+
  # a single empty line is allowed - 2 empty lines ends the meta_block
  (^\ *\n){0,1}
/x

single_key = /
  # Cannot begin with spaces (that's a value)
  ^(?!\ )
  # the key
  ([\S\ ]+):\ 
  # the value
  ([^\n]+)\n
  # a single empty line is allowed - 2 empty lines ends the meta_block
  (^\ *\n){0,1}
/x

# -------------------------

# If the first thing in the document (aside from comments) is a
# key-value pair, then enable tagging of the meta block

# returns the fist non-comment line
l1_test = /^(?! *(#|=|\|\[\[|\/\*)).+/.match(text)
# convert match to string
l1_test = l1_test[0]

# if the first line contains a colon and an optional space, set the
# "meta" variable
if l1_test =~ /: */
  meta = true
else
  meta = false
end

# -------------------------

# debugging switches

debug = true

# -------------------------

# If the first (non-comment) line looks like a meta tag...
# then assume everything that follows is a block of meta tags

if meta == true

  # Find the FIRST occurance of what looks like a meta_block and tag it.
  # Very important that this is "sub" and not "gsub" - gsub will match
  # everything in the document that looks like meta tags - not a
  # great idea.
  text = text.sub(/(#{multi_key}|#{single_key})+/,'<meta_block>'+"\n"+'\0'+'</meta_block>'+"\n\n")

  # Identify multi-line key-value pairs...

    # search for multi-line key-value pairs - and tag with markup
    text = text.gsub(/<meta_block>(.|\n)+?<\/meta_block>/){|tags|
      tags.gsub(/#{multi_key}/, '<meta_multi>'+"\n"+'\0'+"\n"+'</meta_multi>'+"\n")
    }

    # search inside meta for keys
    text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
      tags.gsub(/(.+): */, '<key>\1</key>')
    }

    # search inside meta-tags for values
    text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
      tags.gsub(/( {3,}|\t)(.+)/, '<value>\2</value>')
    }

    # clean-up multi-line values
    text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
      tags.gsub(/<\/value>\n<value>/, "\n")
    }

    # remove empty lines
    text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
      tags.gsub(/^\n/, "")
    }

  # Identify single-line key-value pairs

  text = text.gsub(/<meta_block>(.|\n)+?<\/meta_block>/){|tags|
      tags.gsub(/#{single_key}/, '<meta-single><key>\1</key><value>\2</value></meta-single>'+"\n")
    }

  if debug == true
    print text
  end

else
  # if there's no meta info, just print the text
  print text
end


# -------------------------

if meta == true

  # This sets the value of variables based on the meta tags

  # title
  title = text.scan(/<key>title<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # goldman_sluglines
  goldman_sluglines = text.scan(/<key>goldman_sluglines<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # screenbundle_comments
  screenbundle_comments = text.scan(/<key>screenbundle_comments<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # font
  font = text.scan(/<key>font<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # slugline_spacing
  slugline_spacing = text.scan(/<key>slugline_spacing<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # bold_sluglines
  bold_sluglines = text.scan(/<key>bold_sluglines<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # underlined_sluglines
  underlined_sluglines = text.scan(/<key>underlined_sluglines<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # header
  header = text.scan(/<key>header<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

  # footer
  footer = text.scan(/<key>footer<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).to_s

end


# -------------------------

# Set defaults for any undefined value

if title == ""
  title = "A Screenplay"
end

if goldman_sluglines == ""
  goldman_sluglines = "on"
end

if screenbundle_comments == ""
  screenbundle_comments = "on"
end

if font == ""
  font = "Courier Prime"
end

if slugline_spacing == ""
  slugline_spacing = 12
else
  slugline_spacing = slugline_spacing.to_i * 12
end

if bold_sluglines == ""
  bold_sluglines = "on"
end

if underlined_sluglines == ""
  underlined_sluglines = "off"
end

# No need to set head and footer defaults as they should be empty by default



if debug == true
p "title: " + title
p "goldman_sluglines: " + goldman_sluglines
p "screenbundle_comments: " + screenbundle_comments
p "font: " + font
p "slugline_spacing: " + slugline_spacing.to_s
p "bold_sluglines: " + bold_sluglines
p "underlined_sluglines: " + underlined_sluglines
p "header: " + header
p "footer: " + footer
end