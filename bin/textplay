#!/usr/bin/ruby

# Textplay -- A plain-text conversion tool for screenwriters
#
# Copyright (c) 2006 Oliver Taylor
# <http://olivertaylor.net/textplay/>
#
# Textplay was build and tested by Oliver using Ruby 2.0.0p247
# on Mac OS X 10.9 and Final Draft 8.0. It works for me, but I can't
# promise it won't delete your documents or worse; use at your own risk,
# be careful with your data, backup regularly, etc.
# 
# TEXTPLAY LICENCE
#
# Textplay is free software, available under a BSD-style
# open source license.
#
# Copyright 2006, Oliver Taylor http://olivertaylor.net/ All rights
# reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# * Neither the name "Textplay" nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# This software is provided by the copyright holders and contributors
# "as is" and any express or implied warranties, including, but not
# limited to, the implied warranties of merchantability and fitness for
# a particular purpose are disclaimed. In no event shall the copyright
# owner or contributors be liable for any direct, indirect, incidental,
# special, exemplary, or consequential damages (including, but not
# limited to, procurement of substitute goods or services; loss of use,
# data, or profits; or business interruption) however caused and on any
# theory of liability, whether in contract, strict liability, or tort
# (including negligence or otherwise) arising in any way out of the use
# of this software, even if advised of the possibility of such damage.
#
# ---------------------------------------------------------------------

# HOW TEXTPLAY WORKS
# 
# This script works on your text in 5 phases:
# 
# Phase 1 allows the user to define conversion options on the command-line.
# Phase 2 looks for something that looks like fountain title pages,
#         and sets variables based on key/value pairs
# Phase 3 defines header and footer values for HTML and FDX conversion.
#         These blocks of text will be wrapped-around the transformed text
#         when the output file is generated.
# Phase 4 converts the input text to an interal xml markup in preperation for
#         further transformation.
# Phase 5 converts the internal xml markup to the markup requested by the user.
# Phase 6 dumps the result to STDOUT or an output file specified by the user.


# NOTE: PHASE 1 - Options

require 'optparse'
require 'fcntl'

# Setup the options parser
options = {}
optparse = OptionParser.new do|opts|

	# This is the help banner, which just explains the command syntax
	opts.banner = "Usage: textplay [options] [input-path] [output-path]"

	# Help text
	options[:help] = false
	opts.on( '-h', '--help', "Display the help text" ) do
		options[:help] = true
	end

    # Create snippet instead of full document with headers/footers
	options[:snippet] = false
	opts.on( '-s', '--snippet', "Do not include document headers/footers" ) do
		options[:snippet] = true
	end

	# The default conversion type is HTML, if the '-f' option is set, convert to FDX
	options[:fdx] = false
	opts.on( '-f', '--fdx', "Convert to Final Draft .fdx" ) do
		options[:fdx] = true
	end

	# if the '-p' option is set pass the html output to PrinceXML
	options[:pdf] = false
	opts.on( '-p', '--pdf', "Convert to PDF - REQUIRES PrinceXML" ) do
		options[:pdf] = true
	end

	# if the '-x' option is set use the internal xml format for export
	options[:xml] = false
	opts.on( '-x', '--xml', "Output as raw XML - for debugging" ) do
		options[:xml] = true
	end

end

# Parse the options and remove them from ARGV
optparse.parse!


help_text = "
TEXTPLAY

Usage: textplay [options] [input-path] [output-path]

• The first argument is always an input-path.
• The second argument is always an output-path.
• If there's no input-path textplay reads from STDIN.
• If there's no output-path textplay prints to STDOUT, PDFs go to /temp.

Options:
    -h, --help        Display the help text
    -s, --snippet     Do not include document headers/footers
    -f, --fdx         Convert to Final Draft .fdx instead of HTML
    -p, --pdf         Convert to PDF - REQUIRES PrinceXML
    -x, --xml         Output as the internal raw XML


ABOUT TEXTPLAY

Textplay is a simple ruby-script (one file, no dependancies) that
converts screenplays written in Fountain (http://fountain.io)
formatted plain-text to a variety of useful formats: HTML, FDX (Final
Draft), or PDF (PrinceXML required).

Textplay has been rigorously tested against fountain documents, but
it is not perfect, if you encounter a problem please open a github
issue: http://git.io/textplay.


CONFIGURING TEXTPLAY

Using Fountain's `key:value` title-page syntax, you can control how
textplay interperets your screenplay. The following values can
be customized:

    * title (text) -- default: \"A Screenplay\"

      You can define what name textplay uses when generating files.
 
    * goldman_sluglines (on/off) -- default: on

      By defualt textplay interprets any line that's all-caps as a
      slugline.

    * screenbundle_comments (on/off) -- default: on

      To provide backwards-compatibility with screenbundle documents,
      textplay interprets any line starting with 2 slahes `//` as comments.

    * font (text) -- default: \"Courier Prime\"

      By default textplay uses \"Courier Prime\"
      <http://quoteunquoteapps.com/courierprime/>
      a great alternative font for screenwriters. If you don't have that
      installed plain Courier will be used.
  
      If you'd like to specify your own font, Courier Prime and Courier
      will be used as backup fonts.

    * slugline_spacing (number of 12pt lines) -- default: 1

      By default textplay puts a single empty line above sluglines, you
      can change this to any number you want.

    * bold_sluglines (on/off) -- default: on

    * underlined_sluglines (on/off) -- default: off

    * header (text) -- empty by default

      Header information is displayed on every page, use this for
      revision numbers, dates, etc.

    * footer (text) -- empty by default

      Any information you'd like in the footer of every page can go here.


For the time being, all other key/values are preserved as meta-data in
the document, but otherwise ignored.

To set these values just define the key/values at the beginning of the
document like this:

title: Ron's Woodland Adventure
font: Courier New
goldman_sluglines: off
bold_sluglines: on

The block of key/value pairs:

  a. Must be the first non-comment thing in the document.

  b. Options CAN be wrapped in boneyard comments

  c. Options must NOT be indented

  d. The block of option key/value pairs cannot contain more than
     1 empty line. 2 empty lines will cause textplay to stop parsing
     for options.

For more details see the Fountain documentation 
<http://fountain.io/syntax#section-titlepage>.
"


# NOTE: Input / Output

# Some of this is redundant but I prefer specifying every contingency in case I need to control each step

# if there's a 2nd argument (output path)
if ARGV[1]

  # read the first argument as an input file
  text = File.read(ARGV[0], :encoding => "UTF-8")

# if there's only 1 argument (an input path)
elsif ARGV[0]

  # read the first argument as an input file
  text = File.read(ARGV[0], :encoding => "UTF-8")

# if no input and no output
else

  # check to see if anything is in SDTIN
  if STDIN.fcntl(Fcntl::F_GETFL, 0) == 0
    # if so, read it
    text = STDIN.read 
  else
    # if nothing is check for --help and send help text to less
    if options[:help] == true
      IO.popen("less", "w") { |f| f.puts help_text }
    else
      # otherwise display the option banner
      puts optparse
    end
    exit(-1)
  end

end


# NOTE: PHASE 2 - Set title-page and meta info

# If the first thing in the document (aside from comments) is a
# key-value pair, then enable tagging of the meta block

# returns the fist non-comment line
l1_test = /^(?! *(#|=|\|\[\[|\/\*)).+/.match(text)
# convert match to string
l1_test = l1_test[0]

# if the first line looks like a meta-block, set the "meta" variable
if l1_test =~ /: */
  meta = true
else
  meta = false
end

# -------------------------

# define regex for key-value pairs

multi_key = /
  # Cannot begin with spaces (that's a value)
  ^(?!\ )
  # the key itself
  [\S\ ]+:\ *\n
  # the indented value - multiple lines allowed
  ((\ {3,}|\t).+\n?)+
  # a single empty line is allowed - 2 empty lines ends the meta_block
  (^\ *\n){0,1}
/x

single_key = /
  # Cannot begin with spaces (that's a value)
  ^(?!\ )
  # the key
  ([\S\ ]+):\ 
  # the value
  ([^\n]+)\n
  # a single empty line is allowed - 2 empty lines ends the meta_block
  (^\ *\n){0,1}
/x

# -------------------------

# If the first (non-comment) line looks like a meta tag...
# then assume everything that follows is a block of meta tags

if meta == true

  # Find the FIRST occurance of what looks like a meta_block and tag it.
  # Very important that this is "sub" and not "gsub" - gsub will match
  # everything in the document that looks like meta tags - not a
  # great idea.
  text = text.sub(/(#{multi_key}|#{single_key})+/,'<meta_block>'+"\n"+'\0'+'</meta_block>'+"\n\n")

  # Identify multi-line key-value pairs...

  # search for multi-line key-value pairs - and tag with markup
  text = text.gsub(/<meta_block>(.|\n)+?<\/meta_block>/){|tags|
    tags.gsub(/#{multi_key}/, '<meta_multi>'+"\n"+'\0'+"\n"+'</meta_multi>'+"\n")
  }

  # search inside meta for keys
  text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
    tags.gsub(/(.+): */, '<key>\1</key>')
  }

  # search inside meta-tags for values
  text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
    tags.gsub(/( {3,}|\t)(.+)/, '<value>\2</value>')
  }

  # clean-up multi-line values
  text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
    tags.gsub(/<\/value>\n<value>/, "\n")
  }

  # remove empty lines
  text = text.gsub(/<meta_multi>(.|\n)+?<\/meta_multi>/){|tags|
    tags.gsub(/^\n/, "")
  }

  # Identify single-line key-value pairs

  text = text.gsub(/<meta_block>(.|\n)+?<\/meta_block>/){|tags|
      tags.gsub(/#{single_key}/, '<meta-single><key>\1</key><value>\2</value></meta-single>'+"\n")
    }

end

# -------------------------

if meta == true

  # This sets the value of variables based on the meta tags

  # title
  title = text.scan(/<key>title<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).join

  # goldman_sluglines
  goldman_sluglines = text.scan(/<key>goldman_sluglines<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).join

  # screenbundle_comments
  screenbundle_comments = text.scan(/<key>screenbundle_comments<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).join

  # font
  font = text.scan(/<key>font<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).join

  # slugline_spacing
  slugline_spacing = text.scan(/<key>slugline_spacing<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).join

  # bold_sluglines
  bold_sluglines = text.scan(/<key>bold_sluglines<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).join

  # underlined_sluglines
  underlined_sluglines = text.scan(/<key>underlined_sluglines<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).join

  # header
  header = text.scan(/<key>header<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).join

  # footer
  footer = text.scan(/<key>footer<\/key>\n?<value>([\s\S]+?)(?=<\/value>)/i).join

end


# -------------------------

# Set some defaults for the variables we're about to set

if title == nil or title == ""
  title = "A Screenplay"
end

if goldman_sluglines == nil or goldman_sluglines == ""
goldman_sluglines = "on"
end

if screenbundle_comments == nil or screenbundle_comments == ""
screenbundle_comments = "on"
end

if bold_sluglines == nil or bold_sluglines == ""
bold_sluglines = "on"
end

if underlined_sluglines == nil or underlined_sluglines == ""
underlined_sluglines = "off"
end

if font == nil or font == ""
font = "Courier Prime"
end

if slugline_spacing == nil or slugline_spacing == ""
slugline_spacing = "1"
end

if header == nil or header == ""
header = ""
end

if footer == nil or footer == ""
footer = ""
end

# -------------------------

# Now convert the variable values to CSS for direct-insertion into the CSS

if bold_sluglines == "on"
  bold_sluglines = "bold"
else
  bold_sluglines = "normal"
end

if underlined_sluglines == "on"
  underlined_sluglines = "underline"
else
  underlined_sluglines = "none"
end

# for debugging

# print "title: #{title}\n"
# print "goldman_sluglines: #{goldman_sluglines}\n"
# print "screenbundle_comments: #{screenbundle_comments}\n"
# print "bold_sluglines: #{bold_sluglines}\n"
# print "underlined_sluglines: #{underlined_sluglines}\n"
# print "font: #{font}\n"
# print "slugline_spacing: #{slugline_spacing}\n"
# print "header: #{header}\n"
# print "footer: #{footer}\n"
# print "\n\n" + text

# -------------------------


# NOTE: PHASE 3 - Set HTML, XML, etc. header and footers

# HTML page structure and CSS
htmlStart = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"
\"http://www.w3.org/TR/html4/strict.dtd\">
<html>
<head>
<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">
<title>#{title}</title>
<meta name=\"generator\" content=\"Textplay\">
<style type=\"text/css\" media=\"all\">

/* ---------- PAGE STYLES ---------- */

/* all page margins are maximums */
@page {
size: 8.5in 11in;
margin-top:1in;
margin-right:1in;
margin-bottom:.5in;
margin-left:1.5in;
}
/* This makes the page-counter start on the first page of the screenplay */
div#screenplay {
counter-reset: page 1;
page: Screenplay;
prince-page-group: start;
}
@page Screenplay {
/* Page Numbers */
@top-right-corner {
font: 12pt \"#{font}\", courier;
content: counter(page)\".\";
vertical-align: bottom;
padding-bottom: 1em;
}
/* Define Header */
@top-left {
content: \"\";
font: italic 10pt Georgia;
color: #888;
vertical-align: bottom;
padding-bottom: 1.3em;
}
/* Define Footer */
@bottom-left {
content: \"\";
font: italic 10pt Georgia;
color: #888;
vertical-align:top;
padding-top:0;
}
}
/* removes the header and page-numbers from the first page */
@page Screenplay:first {
@top-right-corner { content: normal; }
@top-left { content: normal; }
}
/* These control where page-breaks can and cannot happen */
p {
orphans: 2;
widows: 2;
}
dl {
page-break-inside:avoid;
}
dt, h2, h5 {
page-break-after: avoid;
}
dd.parenthetical {
orphans: 3;
widows: 3;
page-break-before: avoid;
page-break-after: avoid;
}
dd {
page-break-before:avoid;
}
div.page-break {
page-break-after:always;
}
h3 {
page-break-before: avoid;
}
/* by default Prince bookmarks all headings, no thanks */
h3, h4, h5, h6 {
prince-bookmark-level: none;
}

/* ---------- COMMON LAYOUT ---------- */

body {
font-family: \"#{font}\", courier;
font-size: 12pt;
line-height: 1;
}
#screenplay {
width: 6in;
margin:0 auto;
}
p.center {
text-align:center;
margin-left:0;
width:100%;
}
p {
margin-top:12pt;
margin-bottom:12pt;
margin-left:0;
width:auto;
white-space: pre-wrap;
}

/*Character Names*/

dt {
font-weight:normal;
margin-top:1em;
margin-left:2in;
width:4in;
}

/*Parentheticals*/

dd.parenthetical {
margin-left:1.6in;
text-indent:-.12in;
width: 2in;
}

/*Dialogue*/

dd {
margin:0;
margin-left: 1in;
width: 3.5in;
line-height: inherit;
white-space: pre-wrap;
}

/* Dual-Dialogue-blocks */

dl {clear:both;}

dl.dual {
width:2.9in;
clear:none;
}

dl.dual dt, dl.dual dd { margin-left:0; width:100%;}

dl.dual.first {
float:left;
margin-top:-12pt;
}

dl.dual.second {
margin-right:0;
margin-left:auto;
}

dl.dual dt {
text-align:center;
}

dl.dual dd.parenthetical {
width:2.1in;
margin-left:.32in;
}

/* Sluglines and Transitions */

h1,h2,h3,h4,h5,h6 {
font-weight: normal;
font-size: 12pt;
margin-top: 1em;
margin-bottom: 1em;
text-transform:uppercase;
}

/* Full Sluglines */

h2 {
width: inherit;
margin-top: #{slugline_spacing}em;
margin-bottom: 12pt;
margin-left: 0;
text-decoration: #{underlined_sluglines};
font-weight: #{bold_sluglines};
}

/* Right Transitions */

h3 {
margin-left: 4in;
width: 2in;
}

/* Left Transitions */

h4 {

}

/* Goldman Sluglines */

h5 {
margin-top: #{slugline_spacing}em;
font-weight: #{bold_sluglines};
text-decoration: #{underlined_sluglines};
}

span.underline {
text-decoration:underline;
}
.comment {
display:none
}
</style>
</head>
<body>

<div id=\"screenplay\">
"

# HTML footer
htmlEnd = '
</div><!-- end screenplay -->
</body>
</html>
'

# Final Draft's XML header
fdxStart = '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<FinalDraft DocumentType="Script" Template="No" Version="1">
<Content>
'
# Final Draft's XML footer
fdxEnd = '</Content>
</FinalDraft>
'

# XML Header
xmlStart = '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<root>'

# XML Footer
xmlEnd = '</root>'


# NOTE: PHASE 4 - Convert input to XML

# Misc Encoding
text = text.gsub(/^[ \t]*([=-]{3,})[ \t]*$/, '<page-break />')
text = text.gsub(/&/, '&#38;')
text = text.gsub(/([^-])--([^-])/, '\1&#8209;&#8209;\2')
text = text.gsub(/^[ \t]+$/, '')

# -------- fountain escapes
# force lines ending with {to: } to be action instead of transition
text = text.gsub(/^(.+ )TO: +$/, "\n"+'<action>\1TO:</action>')

# escape caps lines => action - when two spaces are at end of line
text = text.gsub(/^[\ \t]*\n([\ \t]*[^\na-z]+)  $/, "\n"+'<action>\1</action>')

# Boneyard
text = text.gsub(/\/\*(.|\n)+?\*\//, '<secret />')

# Fountain [[notes]]
text = text.gsub(/\[{2}[^\]]+\]{2}/,'<secret />')

# Boneyards and Notes are removed from the text because it is impossible
# to prevent additional transformations inside them when newlines are present.
# And since Fountain is an archival-format, there's no need to maintain notes
# across conversions (retaining notes in FDX being an exception).

# Fountain Rules
text = text.gsub(/^[\ \t]*>[ ]*(.+?)[ ]*<[\ \t]*$/, '<center>\1</center>')
text = text.gsub(/^[\ \t]*\>[ \t]*(.*)$/,'<transition>\1</transition>')
text = text.gsub(/^\.(?!\.)[\ \t]*(.*)$/, '<slug>\1</slug>')
text = text.gsub(/\\\*/, '&#42;')

# Strip-out Fountain Sections and Synopses
text = text.gsub(/^[ \t]*#+[ \t]*(.*)/,'<note>\1</note>')
text = text.gsub(/^[ \t]*=[ \t]*(.*)/,'<note>\1</note>')
# these need not be completely removed simply because they do not span multiple lines

if screenbundle_comments == "on"
  # Textplay/Screenbundle comments
  text = text.gsub(/^[ \t]*\/\/\s?(.*)$/, '<note>\1</note>')  
end

# -------- Transitions
# Left-Transitions
text = text.gsub(/
  # Require preceding empty line or beginning of document
  (^[\ \t]* \n | \A)
  # 1 or more words, a space
  ^[\ \t]* (  \w+(?:\ \w+)* [\ ]
  # One of these words
  (UP|IN|OUT|BLACK|WITH)  (\ ON)?
  # Ending with transition punctuation
  ([\.\:][\ ]*)    )\n
  # trailing empty line
  ^[\ \t]*$
/x, "\n"+'<transition>\2</transition>'+"\n")

# Right-Transitions
text = text.gsub(/
# Require preceding empty line or beginning of document
  (^[\ \t]* \n | \A)
# 1 or more words, a space
  ^[\ \t]* (  \w+(?:\ \w+)* [\ ]
# The word "TO"
  (TO)
# Ending in a colon
  (\:)$)\n
  # trailing empty line
  ^[\ \t]*$
/x, "\n"+'<transition>\2</transition>'+"\n")


# ------- Dialogue
# IDENTIFY AND TAG A DIALOGUE-BLOCK
text = text.gsub(/
# Require preceding empty line
^[\ \t]* \n
# Character Name
^[\ \t]* [^a-z\n\t]+ \n
# Dialogue
(^[\ \t]* .+ \n)+
# Require trailing empty line
^[\ \t]*$
/x, "\n"+'<dialogue>'+'\0'+'</dialogue>'+"\n")

# SEARCH THE DIALOGUE-BLOCK FOR CHARACTERS
text = text.gsub(/<dialogue>\n(.|\n)+?<\/dialogue>/x){|character|
	character.gsub(/(<dialogue>\n)[ \t]*([^a-z\n]+)(?=\n)/, '\1<character>\2</character>')
}

# SEARCH THE DIALOGUE-BLOCK FOR PARENTHETICALS
text = text.gsub(/<dialogue>\n(.|\n)+?<\/dialogue>/x){|paren|
	paren.gsub(/^[ \t]*(\([^\)]+\))[ \t]*(?=\n)/, '<paren>\1</paren>')
}

# SEARCH THE DIALOGUE-BLOCK FOR DIALOG
text = text.gsub(/<dialogue>\n(.|\n)+?<\/dialogue>/x){|talk|
	talk.gsub(/^[ \t]*(?! )([^<\n]+)$/, '<talk>\1</talk>')
}


# Dual Dialogue Blocks
# --------------------

# mark dual-dialogue blocks with a <join-marker>
text = text.gsub(/^\n(<dialogue>\n<character>.+?)( +\^)(<\/character>)/, '<join-marker>' + "\n" + '\1\3')

# remove the <join-marker> and add "class" to <dialogue> tag
text = text.gsub(/\n\n<dialogue>\n((?:.+\n)+)<join-marker>\n<dialogue>/, "\n\n" + '<dialogue class="dual first">' + "\n" + '\1' + "\n" + '<dialogue class="dual second">')



# ------- Scene Headings

# FULLY-FORMED SLUGLINES
text = text.gsub(/
# Require leading empty line - or the beginning of file
(?i:^\A | ^[\ \t]* \n)
# Respect leading whitespace
^[\ \t]*
# Standard prefixes, allowing for bold-italic
((?:[\*\_])*(i\.?\/e|int\.?\/ext|ext|int|est)
# A separator between prefix and location
(\ +|.\ ?).*) \n
# Require trailing empty line
^[\ \t]* \n
/xi, "\n"+'<sceneheading>\1</sceneheading>'+"\n\n")

if goldman_sluglines == "on"
  # GOLDMAN SLUGLINES
  text = text.gsub(/
  # Require leading empty line - or the beginning of file
  (?i:^\A | ^[\ \t]* \n)
  # Any line with all-uppercase
  ^[ \t]*(?=\S)([^a-z\<\>\n]+)$
  /x, "\n"+'<slug>\1</slug>')
end

# ------- Misc

# Any untagged paragraph gets tagged as 'action'
text = text.gsub(/^([^\n\<].*)/, '<action>\1</action>')

# Bold, Italic, Underline
text = text.gsub(/([ \t\-_:;>])\*{3}([^\*\n]+)\*{3}(?=[ \t\)\]<\-_&;:?!.,])/, '\1<b><i>\2</i></b>')
text = text.gsub(/([ \t\-_:;>])\*{2}([^\*\n]+)\*{2}(?=[ \t\)\]<\-_&;:?!.,])/, '\1<b>\2</b>')
text = text.gsub(/([ \t\-_:;>])\*{1}([^\*\n]+)\*{1}(?=[ \t\)\]<\-_&;:?!.,])/, '\1<i>\2</i>')
text = text.gsub(/([ \t\-\*:;>])\_{1}([^\_\n]+)\_{1}(?=[ \t\)\]<\-\*&;:?!.,])/, '\1<u>\2</u>')

# This cleans up action paragraphs with line-breaks.
text = text.gsub(/<\/action>[ \t]*(\n)[ \t]*<action>/,'\1')

# TODO: optional re-wrapping of action paragraphs
# if options[:wrap] == true
# end

# Convert tabs to spaces within action
text = text.gsub(/<action>(.|\n)+?<\/action>/x){|tabs|
	tabs.gsub(/\t/, '    ')
}

# This cleans up line-breaks within dialogue blocks
text = text.gsub(/<\/talk>[ \t]*(\n)[ \t]*<talk>/,'\1')




# NOTE: PHASE 5 - Convert XML to requested format

# And here we markup the text according to the set options

# Final Draft formatting
if options[:fdx] == true
  text = text.gsub(/<meta_block>(.|\n)+?<\/meta_block>/, '')
  text = text.gsub(/<secret \/>/, '')
  text = text.gsub(/<note>/, '<Paragraph><ScriptNote><Text>')
  text = text.gsub(/<\/note>/, '</Text></ScriptNote></Paragraph>')
  text = text.gsub(/<b>/, '<Text Style="Bold">')
  text = text.gsub(/<\/b>/, '</Text>')
  text = text.gsub(/<u>/, '<Text Style="Underline">')
  text = text.gsub(/<\/u>/, '</Text>')
  text = text.gsub(/<i>/, '<Text Style="Italic">')
  text = text.gsub(/<\/i>/, '</Text>')
  text = text.gsub(/<page-break \/>/, '<Paragraph Type="Action" StartsNewPage="Yes"><Text></Text></Paragraph>')
  text = text.gsub(/<transition>/, '<Paragraph Type="Transition"><Text>')
  text = text.gsub(/<\/transition>/, '</Text></Paragraph>')
  text = text.gsub(/<(sceneheading|slug)>/, '<Paragraph Type="Scene Heading"><Text>')
  text = text.gsub(/<\/(sceneheading|slug)>/, '</Text></Paragraph>')
  text = text.gsub(/<center>/, '<Paragraph Type="Action" Alignment="Center"><Text>')
  text = text.gsub(/<\/center>/, '</Text></Paragraph>')
  text = text.gsub(/<\/?dialogue>/,'')
  text = text.gsub(/<character>/, '<Paragraph Type="Character"><Text>')
  text = text.gsub(/<\/character>/, '</Text></Paragraph>')
  text = text.gsub(/<paren>/, '<Paragraph Type="Parenthetical"><Text>')
  text = text.gsub(/<\/paren>/, '</Text></Paragraph>')
  text = text.gsub(/<talk>/, '<Paragraph Type="Dialogue"><Text>')
  text = text.gsub(/<\/talk>/, '</Text></Paragraph>')
  text = text.gsub(/<action>/, '<Paragraph Type="Action"><Text>')
  text = text.gsub(/<\/action>/, '</Text></Paragraph>')
elsif options[:xml] == true
  text = text
else
  # default HTML formatting  
  text = text.gsub(/<note>/, '<p class="comment">')
  text = text.gsub(/<\/note>/, '</p>')
  text = text.gsub(/<meta_block>(.|\n)+?<\/meta_block>/, '<!--\0-->')
  text = text.gsub(/<secret \/>/, '')
  text = text.gsub(/<page-break \/>/, '<div class="page-break"></div>')
  text = text.gsub(/<transition>/, '<h3 class="right-transition">')
  text = text.gsub(/<\/transition>/, '</h3>')
  text = text.gsub(/<sceneheading>/, '<h2 class="full-slugline">')
  text = text.gsub(/<\/sceneheading>/, '</h2>')
  text = text.gsub(/<slug>/, '<h5 class="goldman-slugline">')
  text = text.gsub(/<\/slug>/, '</h5>')
  text = text.gsub(/<center>/, '<p class="center">')
  text = text.gsub(/<\/center>/, '</p>')
  text = text.gsub(/<dialogue( class="dual (first|second)")?>/,'<dl\1>')
  text = text.gsub(/<\/dialogue>/,'</dl>')
  text = text.gsub(/<character>/, '<dt class="character">')
  text = text.gsub(/<\/character>/, '</dt>')
  text = text.gsub(/<paren>/, '<dd class="parenthetical">')
  text = text.gsub(/<\/paren>/, '</dd>')
  text = text.gsub(/<talk>/, '<dd class="dialogue">')
  text = text.gsub(/<\/talk>/, '</dd>')
  text = text.gsub(/<action>/, '<p class="action">')
  text = text.gsub(/<\/action>/, '</p>')
end




# NOTE: PHASE 6 - Output

# If an output file is specified then dump preformatted and converted
# text to that file.
if ARGV[1]
	# create a new file at the path suppied by the user
	newFile = File.new(ARGV[1], "w+")
	# if FDX, then do this
	if options[:fdx] == true
		newFile.puts fdxStart
		newFile.puts text
		newFile.puts fdxEnd
	# if PDF, then do this
	elsif options[:pdf] == true
		# create a new temp file for processing
		File.open('/tmp/textplay.html', "w+") do |htmlFile|
		# place the transformed text in the new file
		htmlFile.puts htmlStart
		htmlFile.puts text
		htmlFile.puts htmlEnd
		  end
		# run prince
		system "prince /tmp/textplay.html #{ARGV[1]}"
	elsif options[:xml] == true
    # output xml if requested
		if options[:snippet] == false
		newFile.puts xmlStart
		end
		newFile.puts text
		if options[:snippet] == false
		newFile.puts xmlEnd
		end
	else
    # otherwise fallback to HTML
		if options[:snippet] == false
		newFile.puts htmlStart
		end
		newFile.puts text
		if options[:snippet] == false
		newFile.puts htmlEnd
		end
	end
else
# If no output file is specified then pass the output to STDOUT.
	if options[:fdx] == true
		puts fdxStart
		puts text
		puts fdxEnd
	# in the case of a PDF, create a file in the /tmp dir and open it directly from there
	elsif options[:pdf] == true
		# create a new temp file for processing
		File.open('/tmp/textplay.html', "w+") do |htmlFile|
		# place the transformed text in the new file
		htmlFile.puts htmlStart
		htmlFile.puts text
		htmlFile.puts htmlEnd
			end
		# run prince on that new file
		system "prince /tmp/textplay.html; open /tmp/textplay.pdf"
	elsif options[:xml] == true
    # output xml if requested
		if options[:snippet] == false
		puts xmlStart
		end
        puts text
        if options[:snippet] == false
        puts xmlEnd
        end
	else
    # otherwise fallback to HTML
		if options[:snippet] == false
		puts htmlStart
		end
		puts text
		if options[:snippet] == false
		puts htmlEnd
		end
	end
end
